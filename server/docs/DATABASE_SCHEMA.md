# Choose Your Own Adventure - Database Schema Documentation

## Overview

The application uses PostgreSQL as its primary database with SQLAlchemy as the ORM. The schema is designed to support interactive story creation, management, and tracking through a normalized relational structure.

## Database Tables

### 1. `stories` Table

**Purpose**: Stores the main story metadata and session information.

**Schema Definition** (`models/story.py:8`):
```sql
CREATE TABLE stories (
    id INTEGER PRIMARY KEY,
    title VARCHAR NOT NULL,
    session_id VARCHAR NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX ix_stories_id ON stories (id);
CREATE INDEX ix_stories_title ON stories (title);
CREATE INDEX ix_stories_session_id ON stories (session_id);
```

**Columns**:
- `id` (Integer, Primary Key): Auto-incrementing unique identifier
- `title` (String, Indexed): The story title generated by AI
- `session_id` (String, Indexed): Session identifier for grouping user stories
- `created_at` (DateTime, Timezone-aware): Automatic timestamp of story creation

**Relationships**:
- One-to-Many with `story_nodes` (via `nodes` relationship)

### 2. `story_nodes` Table

**Purpose**: Stores individual story segments and their relationships, forming a tree structure.

**Schema Definition** (`models/story.py:19`):
```sql
CREATE TABLE story_nodes (
    id INTEGER PRIMARY KEY,
    story_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    is_root BOOLEAN DEFAULT FALSE,
    is_ending BOOLEAN DEFAULT FALSE,
    is_winning_ending BOOLEAN DEFAULT FALSE,
    options JSON DEFAULT '[]',
    FOREIGN KEY (story_id) REFERENCES stories(id)
);

CREATE INDEX ix_story_nodes_id ON story_nodes (id);
CREATE INDEX ix_story_nodes_story_id ON story_nodes (story_id);
```

**Columns**:
- `id` (Integer, Primary Key): Auto-incrementing unique identifier
- `story_id` (Integer, Foreign Key): References `stories.id`
- `content` (String): The narrative content of this story segment
- `is_root` (Boolean): Marks the starting node of the story
- `is_ending` (Boolean): Indicates if this node ends the story
- `is_winning_ending` (Boolean): Indicates if this is a successful ending
- `options` (JSON): Array of choice options with structure:
  ```json
  [
    {
      "text": "Option description",
      "node_id": 123
    }
  ]
  ```

**Relationships**:
- Many-to-One with `stories` (via `story` relationship)

### 3. `story_jobs` Table

**Purpose**: Tracks background story generation jobs and their status.

**Schema Definition** (`models/job.py:7`):
```sql
CREATE TABLE story_jobs (
    id INTEGER PRIMARY KEY,
    job_id VARCHAR UNIQUE NOT NULL,
    session_id VARCHAR NOT NULL,
    theme VARCHAR NOT NULL,
    status VARCHAR NOT NULL,
    story_id INTEGER NULL,
    error VARCHAR NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE NULL
);

CREATE INDEX ix_story_jobs_id ON story_jobs (id);
CREATE INDEX ix_story_jobs_job_id ON story_jobs (job_id);
CREATE INDEX ix_story_jobs_session_id ON story_jobs (session_id);
```

**Columns**:
- `id` (Integer, Primary Key): Auto-incrementing unique identifier
- `job_id` (String, Unique, Indexed): UUID for external job tracking
- `session_id` (String, Indexed): Links job to user session
- `theme` (String): User-requested story theme
- `status` (String): Job status (`pending`, `processing`, `completed`, `failed`)
- `story_id` (Integer, Nullable): References completed story ID
- `error` (String, Nullable): Error message if job fails
- `created_at` (DateTime, Timezone-aware): Job creation timestamp
- `completed_at` (DateTime, Nullable): Job completion timestamp

## Entity Relationships

### Entity Relationship Diagram
```
┌─────────────┐       ┌──────────────┐       ┌─────────────┐
│   stories   │       │ story_nodes  │       │ story_jobs  │
├─────────────┤       ├──────────────┤       ├─────────────┤
│ id (PK)     │◄─────►│ id (PK)      │       │ id (PK)     │
│ title       │   │   │ story_id (FK)│       │ job_id      │
│ session_id  │   │   │ content      │       │ session_id  │
│ created_at  │   │   │ is_root      │       │ theme       │
└─────────────┘   │   │ is_ending    │       │ status      │
                  │   │ is_winning   │       │ story_id    │
                  └───│ options      │       │ error       │
                      └──────────────┘       │ created_at  │
                                             │ completed_at│
                                             └─────────────┘
```

### Relationship Details

1. **Stories ↔ Story Nodes** (One-to-Many):
   - One story contains multiple story nodes
   - Each story node belongs to exactly one story
   - Relationship managed via `story_id` foreign key

2. **Session-based Grouping**:
   - Stories and jobs are linked by `session_id`
   - Enables user session tracking across multiple stories
   - No formal foreign key relationship (session-based grouping)

3. **Job-Story Association**:
   - Jobs reference completed stories via `story_id`
   - Nullable relationship (job may fail before story creation)
   - No formal foreign key constraint for flexibility

## Data Flow and Constraints

### Story Node Tree Structure

**Tree Constraints**:
- Each story has exactly one root node (`is_root = True`)
- Non-ending nodes must have options for story progression
- Ending nodes (`is_ending = True`) have no options
- Options contain references to child node IDs

**JSON Options Structure**:
```json
{
  "options": [
    {
      "text": "Take the left path",
      "node_id": 5
    },
    {
      "text": "Take the right path", 
      "node_id": 6
    }
  ]
}
```

### Job Status Lifecycle

**Status Progression**:
```
pending → processing → completed/failed
```

**Status Descriptions**:
- `pending`: Job created, waiting for processing
- `processing`: Story generation in progress
- `completed`: Story successfully generated and saved
- `failed`: Story generation encountered an error

### Session Management

**Session Scope**:
- Sessions group related stories for a user
- Session IDs are UUIDs stored in HTTP-only cookies
- Sessions persist across browser sessions
- No explicit session expiration in database

## Indexes and Performance

### Primary Indexes
- All primary keys have automatic indexes
- `stories.title` indexed for story searches
- `stories.session_id` indexed for session-based queries
- `story_nodes.story_id` indexed for story tree queries
- `story_jobs.job_id` indexed for job status lookups
- `story_jobs.session_id` indexed for user job tracking

### Query Patterns

**Common Queries**:
1. Get story with all nodes: Join `stories` and `story_nodes`
2. Check job status: Query `story_jobs` by `job_id`
3. Get user's stories: Query `stories` by `session_id`
4. Build story tree: Query `story_nodes` by `story_id`

## Database Configuration

### Connection Setup (`db/database.py`)
```python
engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
```

### Table Creation
- Tables created automatically via `Base.metadata.create_all()`
- Called during application startup in `main.py:11`
- Supports incremental schema updates

### Transaction Management
- Uses SQLAlchemy session management
- Background tasks use separate session instances
- Proper session cleanup via context managers and `finally` blocks

## Data Integrity

### Referential Integrity
- `story_nodes.story_id` enforces valid story references
- Options JSON contains valid `node_id` references (application-level validation)

### Data Validation
- Pydantic schemas validate API input/output
- SQLAlchemy models enforce column constraints
- Application logic ensures story tree consistency

### Error Handling
- Failed jobs store error messages for debugging
- Transaction rollback on story generation failures
- Graceful handling of orphaned records